(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{295:function(e,t,r){"use strict";r.r(t);var a=r(14),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-基础"}},[e._v("#")]),e._v(" Vue 基础")]),e._v(" "),t("h2",{attrs:{id:"vue的基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的基本原理"}},[e._v("#")]),e._v(" "),t("code",[e._v("Vue的基本原理")])]),e._v(" "),t("p",[e._v("当一个 Vue 实例创建时，Vue 会遍历 data 中的属性，用 Object.defineProperty（vue3.0 使用 proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。")]),e._v(" "),t("img",{attrs:{src:e.$withBase("/Vue/01.png"),alt:"mixureSecure"}}),e._v(" "),t("h2",{attrs:{id:"双向数据绑定的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定的原理"}},[e._v("#")]),e._v(" "),t("code",[e._v("双向数据绑定的原理")])]),e._v(" "),t("p",[e._v("Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：")]),e._v(" "),t("ol",[t("li",[e._v("需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化")]),e._v(" "),t("li",[e._v("compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),t("li",[e._v("Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: ① 在自身实例化时往属性订阅器(dep)里面添加自己 ② 自身必须有一个 update()方法 ③ 待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。")]),e._v(" "),t("li",[e._v("MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。\n"),t("img",{attrs:{src:e.$withBase("/Vue/02.png"),alt:"mixureSecure"}})])]),e._v(" "),t("h2",{attrs:{id:"使用-object-defineproperty-来进行数据劫持有什么缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-object-defineproperty-来进行数据劫持有什么缺点"}},[e._v("#")]),e._v(" "),t("code",[e._v("使用 Object.defineProperty() 来进行数据劫持有什么缺点？")])]),e._v(" "),t("p",[e._v("在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。")]),e._v(" "),t("p",[e._v("在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用 Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。")]),e._v(" "),t("h2",{attrs:{id:"computed-和-watch-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[e._v("#")]),e._v(" "),t("code",[e._v("Computed 和 Watch 的区别")])]),e._v(" "),t("h4",{attrs:{id:"computed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[e._v("#")]),e._v(" Computed：")]),e._v(" "),t("ul",[t("li",[e._v("它支持缓存，只有依赖的数据发生了变化，才会重新计算")]),e._v(" "),t("li",[e._v("不支持异步，当 Computed 中有异步操作时，无法监听数据的变化")]),e._v(" "),t("li",[e._v("computed 的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 声明过，或者父组件传递过来的 props 中的数据进行计算的。")]),e._v(" "),t("li",[e._v("如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用 computed")]),e._v(" "),t("li",[e._v("如果 computed 属性的属性值是函数，那么默认使用 get 方法，函数的返回值就是属性的属性值；在 computed 中，属性有一个 get 方法和一个 set 方法，当数据发生变化时，会调用 set 方法。")])]),e._v(" "),t("h4",{attrs:{id:"watch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch"}},[e._v("#")]),e._v(" Watch：")]),e._v(" "),t("ul",[t("li",[e._v("它不支持缓存，数据变化时，它就会触发相应的操作")]),e._v(" "),t("li",[e._v("支持异步监听")]),e._v(" "),t("li",[e._v("监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值")]),e._v(" "),t("li",[e._v("当一个属性发生变化时，就需要执行相应的操作")]),e._v(" "),t("li",[e._v("监听数据必须是 data 中声明的或者父组件传递过来的 props 中的数据，当发生变化时，会触发其他操作，函数有两个的参数：\n○ immediate：组件加载立即触发回调函数\n○ deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep 无法监听到数组和对象内部的变化。\n当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用 watch。")])]),e._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结：")]),e._v(" "),t("ul",[t("li",[e._v("computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。")]),e._v(" "),t("li",[e._v("watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。")])]),e._v(" "),t("h4",{attrs:{id:"运用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运用场景"}},[e._v("#")]),e._v(" 运用场景：")]),e._v(" "),t("ul",[t("li",[e._v("当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。")]),e._v(" "),t("li",[e._v("当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);